= Feature Overview and Usage Guide

:toc:
:toclevels: 2
:source-highlighter: coderay

`go-job` is a flexible and extensible job scheduling and execution library for Go that supports arbitrary function execution, custom scheduling, job monitoring, priority queuing, and distributed operation.

This document provides a comprehensive overview of the features and usage of `go-job`.

== Features

`go-job` provides:

* Arbitrary function registration
* Rich scheduling options
* Prioritized and scalable execution
* Strong observability
* Pluggable, distributed storage

Use it to build robust, scalable job systems in Go.

=== Arbitrary Function Execution

`go-job` allows registration and execution of *any* function using Go's `any` type for arguments and results. The executor can be defined with any number of input and output parameters or complet sturucts.


`go-job` allows registration and execution of *any* function using Go's `any` type for arguments and results. The executor can be defined with any number of input and output parameters or with complete struct definitions.

==== Simple Function Example

A job with no input parameters and no return value can be defined as follows:

[source,go]
----
job, err := NewJob(
    WithKind("hello (no input and no return)"),
    WithExecutor(func()  { 
        fmt.Println("Hello, world!")
    }),
)
----

Then schedule this job with no arguments simply by:

[source,go]
----
mgr.ScheduleJob(job)
----

==== Function with Arguments Example

A job with two input parameters and no return value can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("sum (two input and no output)"),
    WithExecutor(func(x int, y int) {
        fmt.Println(x + y)
    }),
)
----

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(42, 58))
----

==== Function with Arguments and Result Example

Use `WithCompleteProcessor()` to capture the result of a job execution. This is useful when the job has a return value.

A job with two input parameters and one output can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("concat (two input and one output)"),
    WithExecutor(func(a string, b string) string {
        return a + " " + b
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("hello", "world"))
----

==== Function with Struct Input and Output

A job with one struct input and one struct output can be defined like this:

[source,go]
----
type concatString struct {
    a string
    b string
    s string
}   

job, err := NewJob(
    WithKind("concat (one struct input and one struct output)"),
    WithExecutor(func(param *concatString) *concatString {
        // Store the concatenated string result in the input struct, and return it
        param.s = param.a + ", " + param.b
        return param
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

Then schedule the jobs with arguments by:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(&concatString{"Hello", "world!"}))
----

This approach supports diverse function signatures and is ideal for both simple and complex use cases. For additional examples, see the link:https://pkg.go.dev/github.com/cybergarage/go-job/job#NewJob[Examples] section in the link:https://pkg.go.dev/github.com/cybergarage/go-job[image:https://pkg.go.dev/badge/github.com/cybergarage/go-job.svg[Go Reference]].

=== Flexible Scheduling

Schedule jobs:

* *Immediately* (default)
* *At a specific time*
* *After a delay*
* *On a recurring cron schedule*

==== Schedule at a Specific Time

[source,go]
----
mgr.ScheduleJob(job, WithScheduleAt(time.Now().Add(10 * time.Minute)))
----

==== Delay Execution

[source,go]
----
mgr.ScheduleJob(job, WithScheduleAfter(5 * time.Second))
----

==== Cron Scheduling

[source,go]
----
mgr.ScheduleJob(job, WithCrontabSpec("0 0 * * *")) // daily at midnight
----

Supports standard cron format: `min hour dom month dow`.

=== Queue Priority & Worker Management

==== Job Priority

[source,go]
----
mgr.ScheduleJob(job, WithPriority(0)) // high-priority
----

Higher-priority jobs are executed before lower-priority ones.

==== Dynamic Worker Pool

[source,go]
----
mgr, _ := NewManager(WithNumWorkers(5))
mgr.Start()
mgr.ResizeWorkers(10)
----

Allows concurrent execution and real-time scalability.

=== Job Observation

==== Handlers for Response and Error

[source,go]
----
job, err := NewJob(
    WithKind("observe"),
    WithExecutor(func(x int) int { return x * 2 }),
    WithCompleteProcessor(func(inst Instance, res []any) {
        inst.Infof("Result: %v", res)
    }),
    WithTerminateProcessor(func(inst Instance, err error) {
        inst.Errorf("Error: %v", err)
    }),
)
mgr.ScheduleJob(job, WithArguments(42))
----

==== State History

[source,go]
----
states := mgr.ProcessHistory(ji)
for _, s := range states {
    fmt.Printf("State: %s at %v\n", s.State(), s.Timestamp())
}
----

==== Log History

[source,go]
----
logs := mgr.ProcessLogs(ji)
for _, log := range logs {
    fmt.Printf("[%s] %v: %s\n", log.Level(), log.Timestamp(), log.Message())
}
----

Provides auditability and debugging capability for each job instance.

=== Distributed Support via Store Interface

`go-job` supports pluggable storage via the `Store` interface.

[source,go]
----
distStore := NewMyDistributedStore(...)
mgr, _ := NewManager(WithStore(distStore))
----

By implementing a custom store (e.g., etcd, FoundationDB), job metadata and execution state can be shared across nodes.

This enables:

* Distributed scheduling
* Cross-node job coordination
* State persistence across restarts
* Fault-tolerant execution

To learn more about the `Store` interface, see link:design.md[Design and Architecture] and link:plugin-guide.md[Extension Guide ] documentation.
