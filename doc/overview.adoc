:toc: macro
:toclevels: 2
:toc-title: Table of Contents:
:source-highlighter: coderay
= Feature Overview and Usage Guide

This document provides a comprehensive overview of the features and usage of `go-job`.

toc::[]

== Features

`go-job` is a flexible and extensible job scheduling and execution library for Go that supports arbitrary function execution, custom scheduling, job monitoring, priority queuing, and distributed operation.

image::img/job-framework.png[]

`go-job` offers the following key features:

=== Arbitrary function registration

Register any Go function as a job, regardless of its signature. This allows you to schedule and execute a wide variety of tasks, from simple functions to complex business logic, without needing to conform to a specific interface.

=== Rich scheduling options

Schedule jobs to run immediately, at a specific time, after a delay, or on a recurring schedule using cron expressions. This flexibility enables you to automate tasks according to your application's needs.

=== Strong observability

Monitor job execution in real time, track state transitions, and access detailed logs and history for each job instance. This provides transparency and makes it easy to debug and audit job processing.

=== Prioritized and scalable execution

Assign priorities to jobs to control execution order, and dynamically scale the number of worker processes to handle varying workloads efficiently. This ensures that urgent tasks are handled promptly and resources are used optimally.

=== Pluggable, distributed storage

Use a variety of storage backends (such as Valkey, etcd, or in-memory) to persist job metadata and state. Distributed storage support enables robust, fault-tolerant job processing across multiple nodes.

== Usage Guide

This section provides practical guidance on how to use `go-job` in your applications.  Follow these examples and explanations to quickly integrate `go-job` into your workflow and take full advantage of its features.

=== Arbitrary Function Execution

With `go-job`, you can register and execute *any Go function* as a job—no matter its signature.  
This means you aren't limited to a specific interface or function type: you can use anything from simple, no-argument functions to complex functions with multiple parameters and return values.

[source,go]
----
// Executor can be any function type
type Executor any

// Examples of valid executors:
// func()                           // no input, no output
// func(int, string) bool           // multiple inputs, one output  
// func(*MyStruct) error            // struct input, error output
// func(a, b int) (int, error)      // multiple inputs and outputs
----

Thanks to this flexibility, you can:

* Use functions with any number and type of parameters
* Return single or multiple values
* Work with basic types (int, string, bool) or complex structs
* Handle errors directly in your job functions

Because `go-job` uses the Go `any` type for executors, you don't need to write adapters or wrappers—just pass your existing functions as they are.

This approach makes it easy to use `go-job` for both simple tasks and advanced workflows.  
For more examples, see the link:https://pkg.go.dev/github.com/cybergarage/go-job/job#NewJob[Examples] section in the link:https://pkg.go.dev/github.com/cybergarage/go-job[image:https://pkg.go.dev/badge/github.com/cybergarage/go-job.svg[Go Reference]].

==== Simple Function Example

A job with no input parameters and no return value can be defined as follows:

[source,go]
----
job, err := NewJob(
    WithKind("hello (no input and no return)"),
    WithExecutor(func()  { 
        fmt.Println("Hello, world!")
    }),
)
----

Then schedule this job with no arguments simply by:

[source,go]
----
mgr.ScheduleJob(job)
----

==== Function with Arguments Example

A job with two input parameters and no return value can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("sum (two input and no output)"),
    WithExecutor(func(x int, y int) {
        fmt.Println(x + y)
    }),
)
----

You can schedule jobs by passing arguments of any type. For example, to schedule a job with integer arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(42, 58))
----

Or, to schedule a job with string arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("42", "58"))
----

`go-job` will automatically convert the provided arguments to match the types expected by the job function, so you can use the most convenient format for your use case.

==== Function with Arguments and Result Example

A job with two input parameters and one output can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("concat (two input and one output)"),
    WithExecutor(func(a string, b string) string {
        return a + ", " + b
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

Use `WithCompleteProcessor()` to capture the result of a job execution. This is useful when the job has a return value.

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("Hello", "world"))
----

==== Function with Struct Input and Output

A job with one struct input and one struct output can be defined like this:

[source,go]
----
type ConcatString struct {
    A string
    B string
    S string
}   

job, err := NewJob(
    WithKind("concat (one struct input and one struct output)"),
    WithExecutor(func(param *ConcatString) *ConcatString {
        // Store the concatenated string result in the input struct, and return it
        param.S = param.A + ", " + param.B
        return param
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

In this example, the result is also saved in the `S` field of the struct.

You can schedule jobs by passing arguments in various formats. For instance, to schedule a job using a struct as an argument:

[source,go]
----
arg := &ConcatString{
    A: "Hello",
    B: "world!",
    S: "",
}
mgr.ScheduleJob(job, WithArguments(arg))
----

Alternatively, you can pass arguments as a JSON string:

[source,go]
----
jsonArg := `{"A": "Hello", "B": "world!"}`
mgr.ScheduleJob(job, WithArguments(jsonArg))
----

`go-job` will automatically convert the provided arguments to the types expected by your job function.  
This means you can use the format that is most convenient for your application, whether it's a struct, JSON, or other supported types.

=== Job Scheduling

`go-job` provides flexible scheduling options to run jobs when you need them:

* *Immediately* - Jobs start executing right away (default behavior)
* *At a specific time* - Schedule jobs to run at an exact date and time
* *After a delay* - Wait a specified duration before starting execution
* *On a recurring schedule* - Use cron expressions for repeated execution

==== Execute Jobs Immediately

By default, jobs are scheduled for immediate execution:

[source,go]
----
// Runs immediately
mgr.ScheduleJob(job)
----

==== Schedule at a Specific Time

Set an exact time for job execution:

[source,go]
----
// Run 10 minutes from now
futureTime := time.Now().Add(10 * time.Minute)
mgr.ScheduleJob(job, WithScheduleAt(futureTime))

// Run at a specific date and time
specificTime := time.Date(2025, 12, 25, 9, 0, 0, 0, time.UTC)
mgr.ScheduleJob(job, WithScheduleAt(specificTime))
----

==== Delay Execution

Add a delay before the job starts:

[source,go]
----
// Wait 5 seconds before execution
mgr.ScheduleJob(job, WithScheduleAfter(5 * time.Second))

// Wait 2 hours before execution
mgr.ScheduleJob(job, WithScheduleAfter(2 * time.Hour))
----

==== Recurring Cron Scheduling

Use cron expressions for repeated job execution:

[source,go]
----
// Run daily at midnight
mgr.ScheduleJob(job, WithCrontabSpec("0 0 * * *"))

// Run every weekday at 9 AM
mgr.ScheduleJob(job, WithCrontabSpec("0 9 * * 1-5"))

// Run every 30 minutes
mgr.ScheduleJob(job, WithCrontabSpec("*/30 * * * *"))
----

Cron format: `minute hour day-of-month month day-of-week`

=== Job Monitoring and Observability

`go-job` provides comprehensive monitoring capabilities to track job execution and understand system behavior. You can monitor jobs in real-time using event handlers, or query historical data using manager methods.

==== Real-time Monitoring with Event Handlers

Monitor job execution as it happens by registering event handlers that respond to completion, termination, and state changes.

===== Completion and Termination Handlers

Use `WithCompleteProcessor()` and `WithTerminateProcessor()` to handle successful completion and error termination:

[source,go]
----
job, err := NewJob(
    ....,
    WithCompleteProcessor(func(inst Instance, res []any) {
        inst.Infof("Result: %v", res)
    }),
    WithTerminateProcessor(func(inst Instance, err error) {
        inst.Errorf("Error: %v", err)
    }),
)
----

===== State Change Monitoring

Use `WithStateChangeProcessor()` to track every state transition throughout a job's lifecycle:

[source,go]
----
job, err := NewJob(
    ....,
    WithStateChangeProcessor(func(inst Instance, state JobState) error {
        inst.Infof("State changed to: %v", state)
        return nil
    }),
)
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

==== Historical Data Queries

Query job instances and their execution history using manager methods.

===== List All job Instances

With `Manager::LookupInstances()`, you can retrieve any job instance—whether it is scheduled, in progress, or already executed.

====== List All Queued and Executed Job Instances

[source,go]
----
query := job.NewQuery() // queries all job instances (any state)
jis, err := mgr.LookupInstances(query)
if err != nil {
    t.Errorf("Failed to lookup job instance: %v", err)
}
for _, ji := range jis {
    fmt.Printf("Job Instance: %s, UUID: %s, State: %s\n", ji.Kind(), ji.UUID(), ji.State())
}
----

====== List Terminated Job Instances

[source,go]
----
query := job.NewQuery(
    job.WithQueryKind("sum"), // filter by job kind
    job.WithQueryState(job.JobTerminated), // filter by terminated state
)
jis, err := mgr.LookupInstances(query)
if err != nil {
    t.Errorf("Failed to lookup job instance: %v", err)
}
for _, ji := range jis {
    fmt.Printf("Job Instance: %s, State: %s\n", ji.Kind(), ji.State())
}
----

===== Retrieve History and Logs for Job Instances

You can use manager methods to access the processing history and logs of any specified job instance.

====== State History

With `Manager::LookupInstanceHistory`, you can retrieve the state history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
states := mgr.LookupInstanceHistory(query)
for _, s := range states {
    fmt.Printf("State: %s at %v\n", s.State(), s.Timestamp())
}
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

====== Log History

With `Manager::LookupInstanceLogs`, you can retrieve the log history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
logs := mgr.LookupInstanceLogs(query)
for _, log := range logs {
    fmt.Printf("[%s] %v: %s\n", log.Level(), log.Timestamp(), log.Message())
}
----

Provides auditability and debugging capability for each job instance.

=== Priority Management & Worker Scaling

`go-job` allows you to control job execution order through priorities and dynamically scale workers to handle varying workloads.

==== Job Priority Control

Assign priorities to jobs to control their execution order. Higher priority jobs are executed before lower priority ones. The priority value is an integer where lower values indicate higher priority (similar to Unix nice values).

===== Set Priority During Job Creation

[source,go]
----
// High priority job (executed first)
highPriorityJob, err := NewJob(
    WithKind("urgent-task"),
    WithPriority(0), // lower number = higher priority like Unix nice values
    WithExecutor(func() { fmt.Println("Urgent task executing") }),
)

// Low priority job (executed later)
lowPriorityJob, err := NewJob(
    WithKind("background-task"),
    WithPriority(200), // higher number = lower priority like Unix nice values
    WithExecutor(func() { fmt.Println("Background task executing") }),
)
----

===== Override Priority at Schedule Time

You can override a job's default priority when scheduling:

[source,go]
----
// Schedule with default priority
mgr.ScheduleJob(normalJob) // uses job's configured priority

// Schedule with custom priority (overrides job's default priority)
mgr.ScheduleJob(normalJob, WithPriority(200)) // make this instance low priority
----

==== Dynamic Worker Pool Management

Scale your worker pool up or down based on workload demands without stopping the manager.

===== Set Initial Worker Count

[source,go]
----
// Start with 5 workers
mgr, err := NewManager(WithNumWorkers(5))
mgr.Start()
----

===== Scale Workers Dynamically

[source,go]
----
// Scale up during high load
mgr.ResizeWorkers(10) // increase to 10 workers

// Scale down during low load
mgr.ResizeWorkers(3)  // reduce to 3 workers

// Get current worker count
count := mgr.NumWorkers()
fmt.Printf("Current workers: %d\n", count)
----

===== Real-world Scaling Example

[source,go]
----
// Monitor queue size and scale accordingly
query := job.NewQuery(
    job.WithQueryState(job.JobScheduled), // filter by scheduled state
)
jobs, _ := mgr.LookupInstances(query)
queueSize := len(jobs)
currentWorkers := mgr.NumWorkers()
if queueSize > currentWorkers*2 {
    // Scale up if queue is getting too long
    mgr.ResizeWorkers(currentWorkers + 2)
} else if queueSize == 0 && currentWorkers > 2 {
    // Scale down if no jobs queued
    mgr.ResizeWorkers(currentWorkers - 1)
}
----

This enables efficient resource utilization and responsive performance under varying workloads.


=== Remote Management with gRPC API

`go-job` provides a comprehensive gRPC API for remote job management, enabling you to schedule, monitor, and control jobs from external systems or distributed environments. This allows seamless integration with microservices, orchestration platforms, and remote applications.

image::img/job-framework.png[]

==== Server vs. Manager: When to Use Each

`go-job` provides both a *Manager* and a *Server* component, each serving different use cases:

* The **Manager** is the core API for embedding job scheduling and execution directly into your Go application. Use the Manager when you want to control jobs programmatically within your own process, such as in microservices, batch processors, or custom automation tools.

* The **Server** is a standalone process that exposes the Manager's functionality over a gRPC API. Use the Server when you need to manage jobs remotely, integrate with external systems, or provide job scheduling as a service across multiple applications or environments.

Typical usage patterns:

- **Use Manager**:
    - When building an application that needs to schedule and execute jobs internally.
    - When you want full control and direct access to job APIs in Go.
    - For tight integration with your application's business logic.

- **Use Server**:
    - When you want to provide job scheduling as a centralized service.
    - When you need remote access via gRPC (e.g., from other languages or platforms).
    - For distributed or multi-tenant environments where jobs are managed externally.

You can also combine both: run the Server for remote access, and embed a Manager in your application for local job execution. The Server uses a Manager internally, so all features are available through both interfaces.

==== Remote Operation with gRPC API

`go-job` provides a gRPC API for remote job management, scheduling, and monitoring. This enables integration with external systems and remote orchestration. The gRPC API offers full programmatic access to all core `go-job` functionality:

* Remote job scheduling with arguments and timing options
* Real-time job monitoring and status queries  
* Dynamic worker pool management
* Cross-platform compatibility through protocol buffers
* Secure communication with authentication support

The gRPC API uses protobuf messages for job definitions, arguments, and results. For more details, see the link:grpc-api.md[grpc.proto] definition.

==== Command-Line Interface (jobctl)

`go-job` provides a command-line interface called link:./cmd/cli/jobctl.md[jobctl] to interact with the gRPC API. The following methods are available:

* `ScheduleJob` - Schedule a new job remotely with arguments and scheduling options
* `ListJobs` - List all registered jobs and their metadata
* `ListInstances` - Query job instances by kind, state, or time range

For more details, see the link:./cmd/cli/jobctl.md[Command-Line Interface (jobctl)] documentation.

=== Distributed Support via Store Interface

`go-job` makes it easy to build distributed systems by allowing you to plug in different storage backends using the `Store` interface.  
This means that multiple `go-job` instances can work together and share job data through a common store, as shown in the diagram below:

image::img/job-store.png[]

By choosing or implementing a suitable store (such as etcd or Valkey), you can ensure that job metadata and execution state are accessible from any node in your system.

This approach enables:

* Distributed job scheduling across multiple nodes
* Coordination of jobs between different servers
* Persistence of job state even if a node restarts
* Fault-tolerant execution, so jobs are not lost if a node fails

`go-job` comes with several built-in store plugins you can use right away:

[format="csv", options="header"]
|===
include::inc/store_plugins.csv[]
|===

For more details about the `Store` interface and how to extend it, see the link:design.md[Design and Architecture] and link:extension-guide.md[Extension Guide] documentation.

===== Valkey Store Plugin

`Valkey` is a fast and lightweight key-value store built on the Valkey library.  
It offers a simple and efficient way to store and retrieve job metadata and state in `go-job`.

To use the Valkey store plugin, create a manager instance with Valkey as the backend:

```go
import (
    "net"

    "github.com/cybergarage/go-job/job"
    "github.com/cybergarage/go-job/job/plugins/store"
    "github.com/valkey-io/valkey-go"
)

func main() {
    valkeyOpt := valkey.ClientOption{
        InitAddress: []string{net.JoinHostPort("10.0.0.10", "6379")},
    }
    mgr, err := job.NewManager(
        job.WithStore(store.NewValkeyStore(valkeyOpt)),
    )
}
```

===== Etcd Store Plugin

`etcd` is a distributed key-value store used to manage job metadata and state in `go-job`.  
It is built on the etcd v3 API and provides advanced features such as lease-based locking and real-time notifications using the watch mechanism.

To use the etcd store plugin, simply create a new manager instance with etcd as the backend:

```go
import (
    "net"

    "github.com/cybergarage/go-job/job"
    "github.com/cybergarage/go-job/job/plugins/store"
    v3 "go.etcd.io/etcd/client/v3"
)

func main() {
	etcdOpt := v3.Config{
		Endpoints: []string{net.JoinHostPort("10.0.0.10", "2379")},
	}
	mgr, err := job.NewManager(
		job.WithStore(store.NewEtcdStore(etcdOpt)),
	)
}
```