= Feature Overview and Usage Guide

:toc:
:toclevels: 2
:source-highlighter: coderay

`go-job` is a flexible and extensible job scheduling and execution library for Go that supports arbitrary function execution, custom scheduling, job monitoring, priority queuing, and distributed operation.

image::img/job-framework.png[]

This document provides a comprehensive overview of the features and usage of `go-job`.

== Features

`go-job` provides:

* Arbitrary function registration
* Rich scheduling options
* Strong observability
* Prioritized and scalable execution
* Pluggable, distributed storage

Use it to build robust, scalable job systems in Go.

=== Arbitrary Function Execution

`go-job` allows you to register and execute *any Go function* as a job. You can use functions with different signatures - from simple functions with no parameters to complex functions with multiple inputs and outputs.

[source,go]
----
// Executor can be any function type
type Executor any

// Examples of valid executors:
// func()                           // no input, no output
// func(int, string) bool           // multiple inputs, one output  
// func(*MyStruct) error            // struct input, error output
// func(a, b int) (int, error)      // multiple inputs and outputs
----

This flexibility means you can:

* Use functions with any number of parameters
* Return single values or multiple values
* Work with primitive types (int, string, bool)
* Pass complex structs as arguments
* Handle errors in your job functions

The `any` type allows `go-job` to work with your existing functions without requiring special interfaces or wrapper code.

==== Simple Function Example

A job with no input parameters and no return value can be defined as follows:

[source,go]
----
job, err := NewJob(
    WithKind("hello (no input and no return)"),
    WithExecutor(func()  { 
        fmt.Println("Hello, world!")
    }),
)
----

Then schedule this job with no arguments simply by:

[source,go]
----
mgr.ScheduleJob(job)
----

==== Function with Arguments Example

A job with two input parameters and no return value can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("sum (two input and no output)"),
    WithExecutor(func(x int, y int) {
        fmt.Println(x + y)
    }),
)
----

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(42, 58))
----

==== Function with Arguments and Result Example

A job with two input parameters and one output can be defined like this:

[source,go]
----
job, err := NewJob(
    WithKind("concat (two input and one output)"),
    WithExecutor(func(a string, b string) string {
        return a + ", " + b
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

Use `WithCompleteProcessor()` to capture the result of a job execution. This is useful when the job has a return value.

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("Hello", "world"))
----

==== Function with Struct Input and Output

A job with one struct input and one struct output can be defined like this:

[source,go]
----
type concatString struct {
    a string
    b string
    s string
}   

job, err := NewJob(
    WithKind("concat (one struct input and one struct output)"),
    WithExecutor(func(param *concatString) *concatString {
        // Store the concatenated string result in the input struct, and return it
        param.s = param.a + ", " + param.b
        return param
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

In this case, the result is also stored in the struct field `s`.

Then schedule the jobs with arguments by:

[source,go]
----
arg := &concatString{
    a: "Hello",
    b: "world!",
    s: "",
}
mgr.ScheduleJob(job, WithArguments(arg))
----

This approach supports diverse function signatures and is ideal for both simple and complex use cases. For additional examples, see the link:https://pkg.go.dev/github.com/cybergarage/go-job/job#NewJob[Examples] section in the link:https://pkg.go.dev/github.com/cybergarage/go-job[image:https://pkg.go.dev/badge/github.com/cybergarage/go-job.svg[Go Reference]].

=== Job Scheduling

`go-job` provides flexible scheduling options to run jobs when you need them:

* *Immediately* - Jobs start executing right away (default behavior)
* *At a specific time* - Schedule jobs to run at an exact date and time
* *After a delay* - Wait a specified duration before starting execution
* *On a recurring schedule* - Use cron expressions for repeated execution

==== Execute Jobs Immediately

By default, jobs are scheduled for immediate execution:

[source,go]
----
// Runs immediately
mgr.ScheduleJob(job)
----

==== Schedule at a Specific Time

Set an exact time for job execution:

[source,go]
----
// Run 10 minutes from now
futureTime := time.Now().Add(10 * time.Minute)
mgr.ScheduleJob(job, WithScheduleAt(futureTime))

// Run at a specific date and time
specificTime := time.Date(2025, 12, 25, 9, 0, 0, 0, time.UTC)
mgr.ScheduleJob(job, WithScheduleAt(specificTime))
----

==== Delay Execution

Add a delay before the job starts:

[source,go]
----
// Wait 5 seconds before execution
mgr.ScheduleJob(job, WithScheduleAfter(5 * time.Second))

// Wait 2 hours before execution
mgr.ScheduleJob(job, WithScheduleAfter(2 * time.Hour))
----

==== Recurring Cron Scheduling

Use cron expressions for repeated job execution:

[source,go]
----
// Run daily at midnight
mgr.ScheduleJob(job, WithCrontabSpec("0 0 * * *"))

// Run every weekday at 9 AM
mgr.ScheduleJob(job, WithCrontabSpec("0 9 * * 1-5"))

// Run every 30 minutes
mgr.ScheduleJob(job, WithCrontabSpec("*/30 * * * *"))
----

Cron format: `minute hour day-of-month month day-of-week`

=== Job Monitoring and Observability

`go-job` provides comprehensive monitoring capabilities to track job execution and understand system behavior. You can monitor jobs in real-time using event handlers, or query historical data using manager methods.

==== Real-time Monitoring with Event Handlers

Monitor job execution as it happens by registering event handlers that respond to completion, termination, and state changes.

===== Completion and Termination Handlers

Use `WithCompleteProcessor()` and `WithTerminateProcessor()` to handle successful completion and error termination:

[source,go]
----
job, err := NewJob(
    ....,
    WithCompleteProcessor(func(inst Instance, res []any) {
        inst.Infof("Result: %v", res)
    }),
    WithTerminateProcessor(func(inst Instance, err error) {
        inst.Errorf("Error: %v", err)
    }),
)
----

===== State Change Monitoring

Use `WithStateChangeProcessor()` to track every state transition throughout a job's lifecycle:

[source,go]
----
job, err := NewJob(
    ....,
    WithStateChangeProcessor(func(inst Instance, state JobState) error {
        inst.Infof("State changed to: %v", state)
        return nil
    }),
)
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

==== Historical Data Queries

Query job instances and their execution history using manager methods.

===== List All job Instances

With `Manager::LookupInstances()`, you can retrieve any job instanceâ€”whether it is scheduled, in progress, or already executed.

====== List All Queued and Executed Job Instances

[source,go]
----
	query := job.NewQuery() // queries all job instances (any state)
	jis, err := mgr.LookupInstances(query)
	if err != nil {
		t.Errorf("Failed to lookup job instance: %v", err)
	}
    for _, ji := range jis {
		fmt.Printf("Job Instance: %s, UUID: %s, State: %s\n", ji.Kind(), ji.UUID(), ji.State())
    }
----

====== List Terminated Job Instances

[source,go]
----
    query := job.NewQuery(
        job.WithQueryKind("sum"), // filter by job kind
        job.WithQueryState(job.JobTerminated), // filter by terminated state
    )
	jis, err := mgr.LookupInstances(query)
	if err != nil {
		t.Errorf("Failed to lookup job instance: %v", err)
	}
    for _, ji := range jis {
        fmt.Printf("Job Instance: %s, State: %s\n", ji.Kind(), ji.State())
    }
----

===== Retrieve History and Logs for Job Instances

You can use manager methods to access the processing history and logs of any specified job instance.

====== State History

With `Manager::LookupInstanceHistory`, you can retrieve the state history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
states := mgr.LookupInstanceHistory(query)
for _, s := range states {
    fmt.Printf("State: %s at %v\n", s.State(), s.Timestamp())
}
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

====== Log History

With `Manager::LookupInstanceLogs`, you can retrieve the log history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
logs := mgr.LookupInstanceLogs(query)
for _, log := range logs {
    fmt.Printf("[%s] %v: %s\n", log.Level(), log.Timestamp(), log.Message())
}
----

Provides auditability and debugging capability for each job instance.

=== Priority Management & Worker Scaling

`go-job` allows you to control job execution order through priorities and dynamically scale workers to handle varying workloads.

==== Job Priority Control

Assign priorities to jobs to control their execution order. Higher priority jobs are executed before lower priority ones. The priority value is an integer where lower values indicate higher priority (similar to Unix nice values).

===== Set Priority During Job Creation

[source,go]
----
// High priority job (executed first)
highPriorityJob, err := NewJob(
    WithKind("urgent-task"),
    WithPriority(0), // lower number = higher priority like Unix nice values
    WithExecutor(func() { fmt.Println("Urgent task executing") }),
)

// Low priority job (executed later)
lowPriorityJob, err := NewJob(
    WithKind("background-task"),
    WithPriority(200), // higher number = lower priority like Unix nice values
    WithExecutor(func() { fmt.Println("Background task executing") }),
)
----

===== Override Priority at Schedule Time

You can override a job's default priority when scheduling:

[source,go]
----
// Schedule with default priority
mgr.ScheduleJob(normalJob) // uses job's configured priority

// Schedule with custom priority (overrides job's default priority)
mgr.ScheduleJob(normalJob, WithPriority(200)) // make this instance low priority
----

==== Dynamic Worker Pool Management

Scale your worker pool up or down based on workload demands without stopping the manager.

===== Set Initial Worker Count

[source,go]
----
// Start with 5 workers
mgr, err := NewManager(WithNumWorkers(5))
mgr.Start()
----

===== Scale Workers Dynamically

[source,go]
----
// Scale up during high load
mgr.ResizeWorkers(10) // increase to 10 workers

// Scale down during low load
mgr.ResizeWorkers(3)  // reduce to 3 workers

// Get current worker count
count := mgr.NumWorkers()
fmt.Printf("Current workers: %d\n", count)
----

===== Real-world Scaling Example

[source,go]
----
// Monitor queue size and scale accordingly
query := job.NewQuery(
    job.WithQueryState(job.JobScheduled), // filter by scheduled state
)
jobs, _ := mgr.LookupInstances(query)
queueSize := len(jobs)
currentWorkers := mgr.NumWorkers()
if queueSize > currentWorkers*2 {
    // Scale up if queue is getting too long
    mgr.ResizeWorkers(currentWorkers + 2)
} else if queueSize == 0 && currentWorkers > 2 {
    // Scale down if no jobs queued
    mgr.ResizeWorkers(currentWorkers - 1)
}
----

This enables efficient resource utilization and responsive performance under varying workloads.


=== Remote Management with gRPC API

`go-job` provides a comprehensive gRPC API for remote job management, enabling you to schedule, monitor, and control jobs from external systems or distributed environments. This allows seamless integration with microservices, orchestration platforms, and remote applications.

==== Remote Operation with gRPC API

`go-job` provides a gRPC API for remote job management, scheduling, and monitoring. This enables integration with external systems and remote orchestration. The gRPC API offers full programmatic access to all core `go-job` functionality:

* Remote job scheduling with arguments and timing options
* Real-time job monitoring and status queries  
* Dynamic worker pool management
* Cross-platform compatibility through protocol buffers
* Secure communication with authentication support

The gRPC API uses protobuf messages for job definitions, arguments, and results. For more details, see the link:grpc-api.md[grpc.proto] definition.

==== Command-Line Interface (jobctl)

`go-job` provides a command-line interface called link:./cmd/cli/jobctl.md[jobctl] to interact with the gRPC API. The following methods are available:

* `ScheduleJob` - Schedule a new job remotely with arguments and scheduling options
* `ListJobs` - List all registered jobs and their metadata
* `ListInstances` - Query job instances by kind, state, or time range

For more details, see the link:./cmd/cli/jobctl.md[Command-Line Interface (jobctl)] documentation.

=== Distributed Support via Store Interface

`go-job` supports pluggable storage through the `Store` interface. The following component diagram shows how multiple `go-job` instances can share a single store.

image::img/job-store.png[]

By implementing a custom store (e.g., etcd, FoundationDB), job metadata and execution state can be shared across nodes.

This enables:

* Distributed scheduling
* Cross-node job coordination
* State persistence across restarts
* Fault-tolerant execution

To learn more about the `Store` interface, see link:design.md[Design and Architecture] and link:plugin-guide.md[Extension Guide ] documentation.