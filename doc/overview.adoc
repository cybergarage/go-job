:toc: macro
:toclevels: 2
:toc-title: Table of Contents:
:source-highlighter: coderay
= Feature Overview and Usage Guide

This document provides a comprehensive overview of the features and usage of `go-job`.

toc::[]

== Features

`go-job` is a flexible and extensible job scheduling and execution library for Go that supports arbitrary function execution, custom scheduling, job monitoring, priority queuing, and distributed operation.

image::img/job-framework.png[]

`go-job` offers the following key features:

=== Arbitrary function registration

Register any Go function as a job, regardless of its signature. This allows you to schedule and execute a wide variety of tasks, from simple functions to complex business logic, without needing to conform to a specific interface.

=== Rich scheduling options

Schedule jobs to run immediately, at a specific time, after a delay, or on a recurring schedule using cron expressions. This flexibility enables you to automate tasks according to your application's needs.

=== Strong observability

Monitor job execution in real time, track state transitions, and access detailed logs and history for each job instance. This provides transparency and makes it easy to debug and audit job processing.

=== Prioritized and scalable execution

Assign priorities to jobs to control execution order, and dynamically scale the number of worker processes to handle varying workloads efficiently. This ensures that urgent tasks are handled promptly and resources are used optimally.

=== Pluggable, distributed storage

Use a variety of storage backends (such as Valkey, etcd, or in-memory) to persist job metadata and state. Distributed storage support enables robust, fault-tolerant job processing across multiple nodes.

== Usage Guide

This section provides practical guidance on how to use `go-job` in your applications.  Follow these examples and explanations to quickly integrate `go-job` into your workflow and take full advantage of its features.

=== Arbitrary Function Execution

With `go-job`, you can register and execute *any Go function* as a job—no matter its signature.  
This means you aren't limited to a specific interface or function type: you can use anything from simple, no-argument functions to complex functions with multiple parameters and return values.

[source,go]
----
// Executor can be any function type
type Executor any

// Examples of valid executors:
// func()                           // no input, no output
// func(int, string) bool           // multiple inputs, one output  
// func(*MyStruct) error            // struct input, error output
// func(a, b int) (int, error)      // multiple inputs and outputs
----

Thanks to this flexibility, you can:

* Use functions with any number and type of parameters
* Return single or multiple values
* Work with basic types (int, string, bool) or complex structs
* Handle errors directly in your job functions

Because `go-job` uses the Go `any` type for executors, you don't need to write adapters or wrappers—just pass your existing functions as they are.

This approach makes it easy to use `go-job` for both simple tasks and advanced workflows.  
For more examples, see the link:https://pkg.go.dev/github.com/cybergarage/go-job/job#NewJob[Examples] section in the link:https://pkg.go.dev/github.com/cybergarage/go-job[image:https://pkg.go.dev/badge/github.com/cybergarage/go-job.svg[Go Reference]].

==== Simple Function Example

A job with no input parameters and no return value can be defined as follows:

[source,go]
----
job, err := job.NewJob(
    WithKind("hello (no input and no return)"),
    WithExecutor(func()  { 
        fmt.Println("Hello, world!")
    }),
)
----

Then schedule this job with no arguments simply by:

[source,go]
----
mgr.ScheduleJob(job)
----

==== Function with Arguments Example

A job with two input parameters and no return value can be defined like this:

[source,go]
----
job, err := job.NewJob(
    WithKind("sum (two input and no output)"),
    WithExecutor(func(x int, y int) {
        fmt.Println(x + y)
    }),
)
----

You can schedule jobs by passing arguments of any type. For example, to schedule a job with integer arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(42, 58))
----

Or, to schedule a job with string arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("42", "58"))
----

`go-job` will automatically convert the provided arguments to match the types expected by the job function, so you can use the most convenient format for your use case.

==== Function with Arguments and Result Example

A job with two input parameters and one output can be defined like this:

[source,go]
----
job, err := job.NewJob(
    WithKind("concat (two input and one output)"),
    WithExecutor(func(a string, b string) string {
        return a + ", " + b
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

Use `WithCompleteProcessor()` to capture the result of a job execution. This is useful when the job has a return value.

Then schedule jobs with arguments:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("Hello", "world"))
----

==== Function with Struct Input and Output

A job with one struct input and one struct output can be defined like this:

[source,go]
----
type ConcatString struct {
    A string
    B string
    S string
}   

job, err := job.NewJob(
    WithKind("concat (one struct input and one struct output)"),
    WithExecutor(func(param *ConcatString) *ConcatString {
        // Store the concatenated string result in the input struct, and return it
        param.S = param.A + ", " + param.B
        return param
    }),
    WithCompleteProcessor(func(ji Instance, res []any) {
        // In this case, log the result to the go-job manager
        ji.Infof("%v", res[0])
    }),
)
----

In this example, the result is also saved in the `S` field of the struct.

You can schedule jobs by passing arguments in various formats. For instance, to schedule a job using a struct as an argument:

[source,go]
----
arg := &ConcatString{
    A: "Hello",
    B: "world!",
    S: "",
}
mgr.ScheduleJob(job, WithArguments(arg))
----

Alternatively, you can pass arguments as a JSON string:

[source,go]
----
jsonArg := `{"A": "Hello", "B": "world!"}`
mgr.ScheduleJob(job, WithArguments(jsonArg))
----

`go-job` will automatically convert the provided arguments to the types expected by your job function.  
This means you can use the format that is most convenient for your application, whether it's a struct, JSON, or other supported types.

==== Executor with Auto-Injected

`go-job` supports special auto-injected arguments to allow you to access job context, manager, worker, and instance information directly within your function.

[format="csv", options="header"]
|===
include::inc/auto-injected-arguments.csv[]
|===

These auto-injected arguments are automatically supplied when omitted. They enable you to control job execution, handle cancellation and timeouts, and access useful job-related metadata and methods.

===== Using context.Context for Cancellation and Timeout

If your job function takes a `context.Context` argument, you can easily handle cancellation and timeout.  
For example, you can stop a long-running job when the context is canceled:

[source,go]
----
job, err := job.NewJob(
    WithKind("sleep"),
    WithExecutor(func(ctx context.Context, d time.Duration) { 
        for {
            select {
            case <-ctx.Done():
                // Job is canceled or timed out
                return
            default:
                time.Sleep(d)
            }
        }
    }),
)
----

To schedule this job, pass the duration argument along with a dummy value (the actual context will be injected automatically):

[source,go]
----
mgr.ScheduleJob(job, WithArguments("?", time.Duration(1*time.Hour)))
----

Alternatively, you can specify only the duration argument because auto-injected arguments will be filled in automatically when omitted:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(time.Duration(1*time.Hour)))
----

===== Accessing Manager, Worker, and Instance in Job Functions

You can also use auto-injected arguments like `job.Manager`, `job.Worker`, or `job.Instance` in your job function to get information about the job or control its execution.

For example, to log job details using the `Instance` argument:

[source,go]
----
job, err := job.NewJob(
    WithKind("info (with special instance argument)"),
    WithExecutor(func(ji job.Instance) { 
        // Log job details
        ji.Infof("%s (%s): attempts %d", ji.UUID(), ji.Kind(), ji.Attempts())
    }),
)
----

Schedule this job the same way:

[source,go]
----
mgr.ScheduleJob(job, WithArguments("?"))
----

Or with the placeholder:

[source,go]
----
mgr.ScheduleJob(job, WithArguments(job.Placeholder))
----

These features make it easy to write flexible and powerful job functions that can respond to cancellation, access job metadata, and interact with the job system.

=== Job Scheduling

`go-job` provides flexible scheduling options to run jobs when you need them:

* *Immediately* - Jobs start executing right away (default behavior)
* *At a specific time* - Schedule jobs to run at an exact date and time
* *After a delay* - Wait a specified duration before starting execution
* *On a recurring schedule* - Use cron expressions for repeated execution

==== Execute Jobs Immediately

By default, jobs are scheduled for immediate execution:

[source,go]
----
// Runs immediately
mgr.ScheduleJob(job)
----

==== Schedule at a Specific Time

Set an exact time for job execution:

[source,go]
----
// Run 10 minutes from now
futureTime := time.Now().Add(10 * time.Minute)
mgr.ScheduleJob(job, WithScheduleAt(futureTime))

// Run at a specific date and time
specificTime := time.Date(2025, 12, 25, 9, 0, 0, 0, time.UTC)
mgr.ScheduleJob(job, WithScheduleAt(specificTime))
----

==== Delay Execution

Add a delay before the job starts:

[source,go]
----
// Wait 5 seconds before execution
mgr.ScheduleJob(job, WithScheduleAfter(5 * time.Second))

// Wait 2 hours before execution
mgr.ScheduleJob(job, WithScheduleAfter(2 * time.Hour))
----

==== Recurring Cron Scheduling

Use cron expressions for repeated job execution:

[source,go]
----
// Run daily at midnight
mgr.ScheduleJob(job, WithCrontabSpec("0 0 * * *"))

// Run every weekday at 9 AM
mgr.ScheduleJob(job, WithCrontabSpec("0 9 * * 1-5"))

// Run every 30 minutes
mgr.ScheduleJob(job, WithCrontabSpec("*/30 * * * *"))
----

Cron format: `minute hour day-of-month month day-of-week`

=== Job Monitoring and Observability

`go-job` provides comprehensive monitoring capabilities to track job execution and understand system behavior. You can monitor jobs in real-time using event handlers, or query historical data using manager methods.

==== Real-time Monitoring with Event Handlers

Monitor job execution as it happens by registering event handlers that respond to completion, termination, and state changes.

===== Completion and Termination Handlers

Use `WithCompleteProcessor()` and `WithTerminateProcessor()` to handle successful completion and error termination:

[source,go]
----
job, err := job.NewJob(
    ....,
    WithCompleteProcessor(func(ji Instance, res []any) {
        ji.Infof("Result: %v", res)
    }),
    WithTerminateProcessor(func(ji Instance, err error) {
        ji.Errorf("Error: %v", err)
        return err
    }),
)
----

===== State Change Monitoring

Use `WithStateChangeProcessor()` to track every state transition throughout a job's lifecycle:

[source,go]
----
job, err := job.NewJob(
    ....,
    WithStateChangeProcessor(func(ji Instance, state JobState) {
        ji.Infof("State changed to: %v", state)
    }),
)
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

==== Historical Data Queries

Query job instances and their execution history using manager methods.

===== List All job Instances

With `Manager::LookupInstances()`, you can retrieve any job instance—whether it is scheduled, in progress, or already executed.

====== List All Queued and Executed Job Instances

[source,go]
----
query := job.NewQuery() // queries all job instances (any state)
jis, err := mgr.LookupInstances(query)
if err != nil {
    t.Errorf("Failed to lookup job instance: %v", err)
}
for _, ji := range jis {
    fmt.Printf("Job Instance: %s, UUID: %s, State: %s\n", ji.Kind(), ji.UUID(), ji.State())
}
----

====== List Terminated Job Instances

[source,go]
----
query := job.NewQuery(
    job.WithQueryKind("sum"), // filter by job kind
    job.WithQueryState(job.JobTerminated), // filter by terminated state
)
jis, err := mgr.LookupInstances(query)
if err != nil {
    t.Errorf("Failed to lookup job instance: %v", err)
}
for _, ji := range jis {
    fmt.Printf("Job Instance: %s, State: %s\n", ji.Kind(), ji.State())
}
----

===== Retrieve History and Logs for Job Instances

You can use manager methods to access the processing history and logs of any specified job instance.

====== State History

With `Manager::LookupInstanceHistory`, you can retrieve the state history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
states := mgr.LookupInstanceHistory(query)
for _, s := range states {
    fmt.Printf("State: %s at %v\n", s.State(), s.Timestamp())
}
----

For details on job state transitions, refer to link:design.md[Design and Architecture].

====== Log History

With `Manager::LookupInstanceLogs`, you can retrieve the log history for the specified job instance.

[source,go]
----
query := job.NewQuery(
    job.WithQueryInstance(ji), // filter by specific job instance
)
logs := mgr.LookupInstanceLogs(query)
for _, log := range logs {
    fmt.Printf("[%s] %v: %s\n", log.Level(), log.Timestamp(), log.Message())
}
----

Provides auditability and debugging capability for each job instance.

==== Setting Retry Policy

You can control how many times a job should be retried if it fails, allowing you to build more robust and fault-tolerant workflows.  
The retry policy can be set at both the job definition level and at the time of scheduling a job instance.

To set a default retry policy for all instances of a job, use `WithMaxRetries()` when creating the job.  
This determines the maximum number of times the job will be retried if it fails due to an error, timeout, or cancellation.

[source,go]
----
job, err := job.NewJob(
    WithMaxRetries(1), // Retry once if the job fails
)
----

You can also override the retry policy for a specific job instance at scheduling time by passing `WithMaxRetries()` to `ScheduleJob`.  
This is useful when you want to adjust the retry behavior for certain executions without changing the job's default policy.

[source,go]
----
mgr.ScheduleJob(job, WithMaxRetries(2)) // Retry twice if the job fails
----

If a job instance fails, `go-job` will automatically retry it up to the specified number of times.  

==== Custom Termination Handling

You can define custom logic to handle job termination using `WithTerminateProcessor()`. This allows you to inspect the error, decide whether to retry, transform the error, or perform cleanup actions.

For example, you might want to avoid retrying only for specific errors (such as a timeout):

[source,go]
----
mgr.ScheduleJob(job, 
    WithTerminateProcessor(func(ji Instance, err error) error {
        if errors.Is(err, context.DeadlineExceeded) {
            // Do not retry if the job was terminated due to a deadline being exceeded
            ji.Infof("Job (%s) terminated due to deadline exceeded: %v", ji.Kind(), err)
            return nil
        }
        // Retry for all other errors
        return error
    }),
)
----

The `WithTerminateProcessor` function is called whenever a job instance ends with an error. You can return `nil` to mark the job as successful, return the original error to keep it as failed, or return a new error to transform the result.

==== Setting Backoff Strategy

A backoff strategy controls how long the system waits before retrying a failed job. This helps prevent overwhelming the system or external resources with rapid retries.

You can set a custom backoff strategy using `WithBackoffStrategy()`. The function you provide should return the duration to wait before the next retry attempt.

[source,go]
----
mgr.ScheduleJob(job, WithBackoffStrategy(
    func(ji Instance) time.Duration {
        // Exponential backoff
		return time.Duration(float64(ji.Attempts()) * float64(time.Second) * (0.8 + 0.4*rand.Float64()))
    },
))
----

You can implement more advanced strategies, such as exponential backoff, by adjusting the returned duration based on the number of attempts or other factors.

These features allow you to build robust, fault-tolerant job processing pipelines that can gracefully handle

=== Priority Management & Worker Scaling

`go-job` allows you to control job execution order through priorities and dynamically scale workers to handle varying workloads.

==== Job Priority Control

Assign priorities to jobs to control their execution order. Higher priority jobs are executed before lower priority ones. The priority value is an integer where lower values indicate higher priority (similar to Unix nice values).

===== Set Priority During Job Creation

[source,go]
----
// High priority job (executed first)
highPriorityJob, err := job.NewJob(
    WithKind("urgent-task"),
    WithPriority(0), // lower number = higher priority like Unix nice values
    WithExecutor(func() { fmt.Println("Urgent task executing") }),
)

// Low priority job (executed later)
lowPriorityJob, err := job.NewJob(
    WithKind("background-task"),
    WithPriority(200), // higher number = lower priority like Unix nice values
    WithExecutor(func() { fmt.Println("Background task executing") }),
)
----

===== Override Priority at Schedule Time

You can override a job's default priority when scheduling:

[source,go]
----
// Schedule with default priority
mgr.ScheduleJob(normalJob) // uses job's configured priority

// Schedule with custom priority (overrides job's default priority)
mgr.ScheduleJob(normalJob, WithPriority(200)) // make this instance low priority
----

==== Dynamic Worker Pool Management

Scale your worker pool up or down based on workload demands without stopping the manager.

===== Set Initial Worker Count

[source,go]
----
// Start with 5 workers
mgr, err := NewManager(WithNumWorkers(5))
mgr.Start()
----

===== Scale Workers Dynamically

[source,go]
----
// Scale up during high load
mgr.ResizeWorkers(10) // increase to 10 workers

// Scale down during low load
mgr.ResizeWorkers(3)  // reduce to 3 workers

// Get current worker count
count := mgr.NumWorkers()
fmt.Printf("Current workers: %d\n", count)
----

===== Real-world Scaling Example

[source,go]
----
// Monitor queue size and scale accordingly
query := job.NewQuery(
    job.WithQueryState(job.JobScheduled), // filter by scheduled state
)
jobs, _ := mgr.LookupInstances(query)
queueSize := len(jobs)
currentWorkers := mgr.NumWorkers()
if queueSize > currentWorkers*2 {
    // Scale up if queue is getting too long
    mgr.ResizeWorkers(currentWorkers + 2)
} else if queueSize == 0 && currentWorkers > 2 {
    // Scale down if no jobs queued
    mgr.ResizeWorkers(currentWorkers - 1)
}
----

This enables efficient resource utilization and responsive performance under varying workloads.

=== System Jobs

`go-job` comes with several built-in system jobs that are ready to use.  
You can schedule and configure these jobs just like any other job in your application.

The following table lists each system job and its purpose:

[format="csv", options="header"]
|===
include::inc/job-plugins.csv[]
|===

For step-by-step usage and scheduling examples, see link:extension-guide.md[Extension Guide] documentation or link:../jobtest/example_job_plugins_test.go[the usage examples].

=== Remote Management with gRPC API

`go-job` provides a comprehensive gRPC API for remote job management, enabling you to schedule, monitor, and control jobs from external systems or distributed environments. This allows seamless integration with microservices, orchestration platforms, and remote applications.

image::img/job-framework.png[]

==== Server vs. Manager: Which to Use?

`go-job` provides two main components:

* **Manager**: Embed this in your Go application to schedule and run jobs directly in your process. Use Manager when you want to control jobs from your own code, such as in microservices, batch jobs, or automation tools.
* **Server**: Run as a standalone process to provide job management over a gRPC API. Use Server when you want to manage jobs remotely, integrate with other systems, or offer job scheduling as a service for multiple applications.

When to use each:

- **Manager**: For direct, in-process job control and tight integration with your Go code.
- **Server**: For remote job management, gRPC access, or centralized job scheduling across many apps.

The Server uses a Manager internally, so all features are available.

==== Remote Operation with gRPC API

`go-job` provides a gRPC API for remote job management, scheduling, and monitoring. This enables integration with external systems and remote orchestration. The gRPC API offers full programmatic access to all core `go-job` functionality:

* Remote job scheduling with arguments and timing options
* Real-time job monitoring and status queries  
* Dynamic worker pool management
* Cross-platform compatibility through protocol buffers
* Secure communication with authentication support

The gRPC API uses protobuf messages for job definitions, arguments, and results. For more details, see the link:grpc-api.md[grpc.proto] definition.

==== Command-Line Interface (jobctl)

`go-job` provides a command-line interface called link:./cmd/cli/jobctl.md[jobctl] to interact with the gRPC API. The following methods are available:

* `ScheduleJob` - Schedule a new job remotely with arguments and scheduling options
* `ListJobs` - List all registered jobs and their metadata
* `ListInstances` - Query job instances by kind, state, or time range

For more details, see the link:./cmd/cli/jobctl.md[Command-Line Interface (jobctl)] documentation.

=== Distributed Support via Store Interface

`go-job` makes it easy to build distributed systems by allowing you to plug in different storage backends using the `Store` interface.  
This means that multiple `go-job` instances can work together and share job data through a common store, as shown in the diagram below:

image::img/job-store.png[]

By choosing or implementing a suitable store (such as etcd or Valkey), you can ensure that job metadata and execution state are accessible from any node in your system.

This approach enables:

* Distributed job scheduling across multiple nodes
* Coordination of jobs between different servers
* Persistence of job state even if a node restarts
* Fault-tolerant execution, so jobs are not lost if a node fails

`go-job` comes with several built-in store plugins you can use right away:

[format="csv", options="header"]
|===
include::inc/store-plugins.csv[]
|===

For more details about the `Store` interface and how to extend it, see the link:design.md[Design and Architecture] and link:extension-guide.md[Extension Guide] documentation.

===== Valkey Store Plugin

`Valkey` is a fast and lightweight key-value store built on the Valkey library.  
It offers a simple and efficient way to store and retrieve job metadata and state in `go-job`.

To use the Valkey store plugin, create a manager instance with Valkey as the backend:

```go
import (
    "net"

    "github.com/cybergarage/go-job/job"
    "github.com/cybergarage/go-job/job/plugins/store"
    "github.com/valkey-io/valkey-go"
)

func main() {
    valkeyOpt := valkey.ClientOption{
        InitAddress: []string{net.JoinHostPort("10.0.0.10", "6379")},
    }
    mgr, err := job.NewManager(
        job.WithStore(store.NewValkeyStore(valkeyOpt)),
    )
}
```

===== Etcd Store Plugin

`etcd` is a distributed key-value store used to manage job metadata and state in `go-job`.  
It is built on the etcd v3 API and provides advanced features such as lease-based locking and real-time notifications using the watch mechanism.

To use the etcd store plugin, simply create a new manager instance with etcd as the backend:

```go
import (
    "net"

    "github.com/cybergarage/go-job/job"
    "github.com/cybergarage/go-job/job/plugins/store"
    v3 "go.etcd.io/etcd/client/v3"
)

func main() {
	etcdOpt := v3.Config{
		Endpoints: []string{net.JoinHostPort("10.0.0.10", "2379")},
	}
	mgr, err := job.NewManager(
		job.WithStore(store.NewEtcdStore(etcdOpt)),
	)
}
```