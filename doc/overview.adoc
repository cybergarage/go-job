= Overview

:toc:
:toclevels: 2
:source-highlighter: coderay

This document provides a detailed overview of `go-job`'s features and architecture.
`go-job` is a flexible and extensible job scheduling and execution library for Go,
supporting arbitrary function execution, custom scheduling, job monitoring, priority queuing, and distributed operation.

== Arbitrary Function Execution

`go-job` allows registration and execution of *any* function using Go's `any` type for arguments and results.

[source,go]
----
sumJob, _ := NewJob(
    WithKind("sum"),
    WithExecutor(func(a, b int) int { return a + b }),
)

type concatOpt struct {
    a string
    b string
}
concatJob, _ := NewJob(
    WithKind("concat"),
    WithExecutor(func(opt concatOpt) string {
        return opt.a + " " + opt.b
    }),
)
----

Then schedule the jobs with arguments:

[source,go]
----
mgr.ScheduleJob(sumJob, WithArguments(1, 2))
mgr.ScheduleJob(concatJob, WithArguments(concatOpt{"Hello", "world!"}))
----

This approach supports diverse function signatures and is ideal for both simple and complex use cases.

== Flexible Scheduling

Schedule jobs:

* *Immediately* (default)
* *At a specific time*
* *After a delay*
* *On a recurring cron schedule*

=== Schedule at a Specific Time

[source,go]
----
mgr.ScheduleJob(job, WithScheduleAt(time.Now().Add(10 * time.Minute)))
----

=== Delay Execution

[source,go]
----
mgr.ScheduleJob(job, WithScheduleAfter(5 * time.Second))
----

=== Cron Scheduling

[source,go]
----
mgr.ScheduleJob(job, WithCrontabSpec("0 0 * * *")) // daily at midnight
----

Supports standard cron format: `min hour dom month dow`.

== Queue Priority & Worker Management

=== Job Priority

[source,go]
----
mgr.ScheduleJob(job, WithPriority(10)) // high-priority
----

Higher-priority jobs are executed before lower-priority ones.

=== Dynamic Worker Pool

[source,go]
----
mgr, _ := NewManager(WithNumWorkers(5))
mgr.Start()
mgr.ResizeWorkers(10)
----

Allows concurrent execution and real-time scalability.

== Job Observation

=== Handlers for Response and Error

[source,go]
----
job, _ := NewJob(
    WithKind("observe"),
    WithExecutor(func(x int) int { return x * 2 }),
    WithCompleteProcessor(func(inst Instance, res []any) {
        inst.Infof("Result: %v", res)
    }),
    WithTerminateProcessor(func(inst Instance, err error) {
        inst.Errorf("Error: %v", err)
    }),
)
mgr.ScheduleJob(job, WithArguments(42))
----

=== State History

[source,go]
----
states := mgr.ProcessHistory(ji)
for _, s := range states {
    fmt.Printf("State: %s at %v\n", s.State(), s.Timestamp())
}
----

=== Log History

[source,go]
----
logs := mgr.ProcessLogs(ji)
for _, log := range logs {
    fmt.Printf("[%s] %v: %s\n", log.Level(), log.Timestamp(), log.Message())
}
----

Provides auditability and debugging capability for each job instance.

== Distributed Support via Store Interface

`go-job` supports pluggable storage via the `Store` interface.

[source,go]
----
distStore := NewMyDistributedStore(...)
mgr, _ := NewManager(WithStore(distStore))
----

By implementing a custom store (e.g., etcd, FoundationDB), job metadata and execution state can be shared across nodes.

This enables:

* Distributed scheduling
* Cross-node job coordination
* State persistence across restarts
* Fault-tolerant execution

To learn more about the `Store` interface, see link:design.md[Design and Architecture] and link:plugin-guide.md[Extension Guide ] documentation.

== Summary

`go-job` provides:

* Arbitrary function registration
* Rich scheduling options
* Prioritized and scalable execution
* Strong observability
* Pluggable, distributed storage

Use it to build robust, scalable job systems in Go.
