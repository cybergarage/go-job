:toc: macro
:toclevels: 3
:toc-title: Table of Contents
:toclevels: 2
:source-highlighter: coderay
= Extension Guide 

This guide provides an overview of how to extend `go-job` with custom plugins, allowing you to add new functionality or integrate with external systems.

toc::[]

== Store Plugin Development 

The `go-job` framework supports custom store plugins that can be used to manage job instances, their states, and logs. A store plugin must implement the `Store` interface, which defines methods for managing job instances and their histories.

image::img/job-store.png[]

=== Store Interface

The Store interface specifies the required methods that every store plugin must implement to manage job instances, their states, and logs:

[source,go]
----
// Store defines the interface for job queue, history, and logging.
type Store interface {
    // Name returns the name of the store.
    Name() string
    // PendingStore provides methods for managing job instances.
    QueueStore
    // HistoryStore provides methods for managing job instance state history.
    HistoryStore
    // Start starts the store.
    Start() error
    // Stop stops the store.
    Stop() error
}

// QueueStore is an interface that defines methods for managing job instances in a pending state.
type QueueStore interface {
    // EnqueueInstance stores a job instance in the store.
    EnqueueInstance(ctx context.Context, job Instance) error
    // DequeueNextInstance retrieves and removes the highest priority job instance from the store. If no job instance is available, it returns nil.
    DequeueNextInstance(ctx context.Context) (Instance, error)
    // ListInstances lists all job instances in the store.
    ListInstances(ctx context.Context) ([]Instance, error)
    // ClearInstances clears all job instances in the store.
    ClearInstances(ctx context.Context) error
}

// HistoryStore is an interface that defines methods for managing job instance state history.
type HistoryStore interface {
    // StateStore provides methods for managing job instance state history.
    StateStore
    // LogStore provides methods for logging job instance messages.
    LogStore
}

// StateStore is an interface that defines methods for managing job instance state history.
type StateStore interface {
    // LogInstanceState adds a new state record for a job instance.
    LogInstanceState(ctx context.Context, state InstanceState) error
	// LookupInstanceHistory lists all state records for a job instance that match the specified query. The returned history is sorted by their timestamp.
	LookupInstanceHistory(ctx context.Context, query Query) (InstanceHistory, error)
	// ClearInstanceHistory clears all state records for a job instance that match the specified filter.
	ClearInstanceHistory(ctx context.Context, filter Filter) error
}

// LogStore is an interface that defines methods for logging job instance messages.
type LogStore interface {
    // Infof logs an informational message for a job instance.
    Infof(ctx context.Context, job Instance, format string, args ...any) error
    // Warnf logs a warning message for a job instance.
    Warnf(ctx context.Context, job Instance, format string, args ...any) error
    // Errorf logs an error message for a job instance.
    Errorf(ctx context.Context, job Instance, format string, args ...any) error
	// LookupInstanceLogs lists all log entries for a job instance that match the specified query. The returned logs are sorted by their timestamp.
	LookupInstanceLogs(ctx context.Context, query Query) ([]Log, error)
	// ClearInstanceLogs clears all log entries for a job instance that match the specified filter.
	ClearInstanceLogs(ctx context.Context, filter Filter) error
}
----

=== kv.Store Interface

To create a custom store plugin using a key-value store, `go-job` provides a straightforward key-value store interface.  

This interface makes it easy to build your own plugins for storing and managing job data.  

[source,go]
----
// Store represents a key-value store interface.
type Store interface {
	// UniqueKeys returns whether keys should be unique.
	UniqueKeys() bool
	// Name returns the name of the store.
	Name() string
	// Set stores a key-value object. If the key already holds some value, it is overwritten.
	Set(ctx context.Context, obj Object) error
	// Get returns a key-value object of the specified key.
	Get(ctx context.Context, key Key) (Object, error)
	// Scan returns a result set of all key-value objects whose keys have the specified prefix.
	Scan(ctx context.Context, key Key, opts ...Option) (ResultSet, error)
	// Remove removes the specified key-value object.
	Remove(ctx context.Context, obj Object) error
	// Delete deletes all key-value objects whose keys have the specified prefix.
	Delete(ctx context.Context, key Key) error
	// Dump returns all key-value objects in the store.
	Dump(ctx context.Context) ([]Object, error)
	// Start starts the store.
	Start() error
	// Stop stops the store.
	Stop() error
	// Clear removes all key-value objects from the store.
	Clear() error
}
----

By default, `go-job` provides ready-to-use key-value store implementations for both Valkey and Etcd.

These store plugins are built on top of the `kv.Store` interface, making it easy to use them out of the box or to develop your own custom store plugins based on the same interface.

To use one of these built-in stores, simply create a manager instance and specify the desired backend (Valkey or Etcd) when configuring the store:

===== Valkey Store Plugin

To use the Valkey store plugin, simply create a manager instance with Valkey as the backend:

```go
import (
	"net"

	"github.com/cybergarage/go-job/job"
	"github.com/cybergarage/go-job/job/plugins/store"
	"github.com/cybergarage/go-job/job/plugins/store/kv/valkey"
    v1 "github.com/valkey-io/valkey-go"
)

func main() {
	valkeyOpt := v1.ClientOption{
		InitAddress: []string{net.JoinHostPort("10.0.0.10", "6379")},
	}
	mgr, err := job.NewManager(
		job.WithStore(store.NewKvStoreWith(valkey.NewStore(valkeyOpt))),
	)
}
```

===== Etcd Store Plugin

To use the etcd store plugin, simply create a new manager instance with etcd as the backend:

```go
import (
	"net"

	"github.com/cybergarage/go-job/job"
	"github.com/cybergarage/go-job/job/plugins/store"
	"github.com/cybergarage/go-job/job/plugins/store/kv/etcd"
	v3 "go.etcd.io/etcd/client/v3"
)

func main() {
	etcdOpt := v3.Config{
		Endpoints: []string{net.JoinHostPort("10.0.0.10", "6379")},
	}
	mgr, err := job.NewManager(
		job.WithStore(store.NewKvStoreWith(etcd.NewStore(etcdOpt))),
	)
}
```